class t{constructor(){this.keys=new Set,this.queue=[]}sort(){this.queue.sort((t,e)=>t.priority-e.priority)}set(t,e){const r=Number(e);if(isNaN(r))throw new TypeError('"priority" must be a number');return this.keys.has(t)?this.queue.map(e=>(e.key===t&&Object.assign(e,{priority:r}),e)):(this.keys.add(t),this.queue.push({key:t,priority:r})),this.sort(),this.queue.length}next(){const t=this.queue.shift();return this.keys.delete(t.key),t}isEmpty(){return Boolean(0===this.queue.length)}has(t){return this.keys.has(t)}get(t){return this.queue.find(e=>e.key===t)}}function e(t){const r=new Map;return Object.keys(t).forEach(s=>{const n=t[s];if(null!==n&&"object"==typeof n&&!Array.isArray(n))return r.set(s,e(n));if(!function(t){const e=Number(t);return!(isNaN(e)||e<=0)}(n))throw new Error(`Invalid node: ${s}: ${n}`);return r.set(s,Number(n))}),r}function r(t){if(!(t instanceof Map))throw new Error("Invalid graph: Expected Map instead found "+typeof t);t.forEach((t,e)=>{if("object"==typeof t&&t instanceof Map)r(t);else if("number"!=typeof t||t<=0)throw new Error(`Values must be numbers greater than 0. Found value ${t} at ${e}`)})}export default class{constructor(t){t instanceof Map?(r(t),this.graph=t):this.graph=t?e(t):new Map}addNode(t,s){let n;return s instanceof Map?(r(s),n=s):n=e(s),this.graph.set(t,n),this}addVertex(t,e){return this.addNode(t,e)}removeNode(t){return this.graph=function t(e,r){const s=new Map;for(const[n,i]of e)n!==r&&i instanceof Map?s.set(n,t(i,r)):n!==r&&s.set(n,i);return s}(this.graph,t),this}path(e,r,s={}){if(!this.graph.size)return s.cost?{path:null,cost:0}:null;const n=new Set,i=new t,o=new Map;let a=[],u=0,h=[];if(s.avoid&&(h=[].concat(s.avoid)),h.includes(e))throw new Error(`Starting node (${e}) cannot be avoided`);if(h.includes(r))throw new Error(`Ending node (${r}) cannot be avoided`);for(i.set(e,0);!i.isEmpty();){const t=i.next();if(t.key===r){u=t.priority;let e=t.key;for(;o.has(e);)a.push(e),e=o.get(e);break}n.add(t.key);(this.graph.get(t.key)||new Map).forEach((e,r)=>{if(n.has(r)||h.includes(r))return null;if(!i.has(r))return o.set(r,t.key),i.set(r,t.priority+e);const s=i.get(r).priority,a=t.priority+e;return a<s?(o.set(r,t.key),i.set(r,a)):null})}return a.length?(s.trim?a.shift():a=a.concat([e]),s.reverse||(a=a.reverse()),s.cost?{path:a,cost:u}:a):s.cost?{path:null,cost:0}:null}shortestPath(...t){return this.path(...t)}}
//# sourceMappingURL=index.es.js.map
