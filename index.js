!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).Graph=t()}(this,(function(){"use strict";class e{constructor(){this.keys=new Set,this.queue=[]}sort(){this.queue.sort((e,t)=>e.priority-t.priority)}set(e,t){const r=Number(t);if(isNaN(r))throw new TypeError('"priority" must be a number');return this.keys.has(e)?this.queue.map(t=>(t.key===e&&Object.assign(t,{priority:r}),t)):(this.keys.add(e),this.queue.push({key:e,priority:r})),this.sort(),this.queue.length}next(){const e=this.queue.shift();return this.keys.delete(e.key),e}isEmpty(){return Boolean(0===this.queue.length)}has(e){return this.keys.has(e)}get(e){return this.queue.find(t=>t.key===e)}}function t(e){const r=new Map;return Object.keys(e).forEach(n=>{const s=e[n];if(null!==s&&"object"==typeof s&&!Array.isArray(s))return r.set(n,t(s));if(!function(e){const t=Number(e);return!(isNaN(t)||t<=0)}(s))throw new Error(`Invalid node: ${n}: ${s}`);return r.set(n,Number(s))}),r}function r(e){if(!(e instanceof Map))throw new Error("Invalid graph: Expected Map instead found "+typeof e);e.forEach((e,t)=>{if("object"==typeof e&&e instanceof Map)r(e);else if("number"!=typeof e||e<=0)throw new Error(`Values must be numbers greater than 0. Found value ${e} at ${t}`)})}return class{constructor(e){e instanceof Map?(r(e),this.graph=e):this.graph=e?t(e):new Map}addNode(e,n){let s;return n instanceof Map?(r(n),s=n):s=t(n),this.graph.set(e,s),this}addVertex(e,t){return this.addNode(e,t)}removeNode(e){return this.graph=function e(t,r){const n=new Map;for(const[s,o]of t)s!==r&&o instanceof Map?n.set(s,e(o,r)):s!==r&&n.set(s,o);return n}(this.graph,e),this}path(t,r,n={}){if(!this.graph.size)return n.cost?{path:null,cost:0}:null;const s=new Set,o=new e,i=new Map;let a=[],u=0,h=[];if(n.avoid&&(h=[].concat(n.avoid)),h.includes(t))throw new Error(`Starting node (${t}) cannot be avoided`);if(h.includes(r))throw new Error(`Ending node (${r}) cannot be avoided`);for(o.set(t,0);!o.isEmpty();){const e=o.next();if(e.key===r){u=e.priority;let t=e.key;for(;i.has(t);)a.push(t),t=i.get(t);break}s.add(e.key);(this.graph.get(e.key)||new Map).forEach((t,r)=>{if(s.has(r)||h.includes(r))return null;if(!o.has(r))return i.set(r,e.key),o.set(r,e.priority+t);const n=o.get(r).priority,a=e.priority+t;return a<n?(i.set(r,e.key),o.set(r,a)):null})}return a.length?(n.trim?a.shift():a=a.concat([t]),n.reverse||(a=a.reverse()),n.cost?{path:a,cost:u}:a):n.cost?{path:null,cost:0}:null}shortestPath(...e){return this.path(...e)}}}));
//# sourceMappingURL=index.js.map
