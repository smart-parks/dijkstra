{"version":3,"file":"index.es.js","sources":["libs/PriorityQueue.js","libs/removeDeepFromMap.js","libs/Graph.js"],"sourcesContent":["/**\n * This very basic implementation of a priority queue is used to select the\n * next node of the graph to walk to.\n *\n * The queue is always sorted to have the least expensive node on top.\n * Some helper methods are also implemented.\n *\n * You should **never** modify the queue directly, but only using the methods\n * provided by the class.\n */\nexport class PriorityQueue {\n  /**\n   * Creates a new empty priority queue\n   */\n  constructor() {\n    // The `keys` set is used to greatly improve the speed at which we can\n    // check the presence of a value in the queue\n    this.keys = new Set();\n    this.queue = [];\n  }\n\n  /**\n   * Sort the queue to have the least expensive node to visit on top\n   *\n   * @private\n   */\n  sort() {\n    this.queue.sort((a, b) => a.priority - b.priority);\n  }\n\n  /**\n   * Sets a priority for a key in the queue.\n   * Inserts it in the queue if it does not already exists.\n   *\n   * @param {any}     key       Key to update or insert\n   * @param {number}  value     Priority of the key\n   * @return {number} Size of the queue\n   */\n  set(key, value) {\n    const priority = Number(value);\n    if (isNaN(priority)) throw new TypeError('\"priority\" must be a number');\n\n    if (!this.keys.has(key)) {\n      // Insert a new entry if the key is not already in the queue\n      this.keys.add(key);\n      this.queue.push({ key, priority });\n    } else {\n      // Update the priority of an existing key\n      this.queue.map((element) => {\n        if (element.key === key) {\n          Object.assign(element, { priority });\n        }\n\n        return element;\n      });\n    }\n\n    this.sort();\n    return this.queue.length;\n  }\n\n  /**\n   * The next method is used to dequeue a key:\n   * It removes the first element from the queue and returns it\n   *\n   * @return {object} First priority queue entry\n   */\n  next() {\n    const element = this.queue.shift();\n\n    // Remove the key from the `_keys` set\n    this.keys.delete(element.key);\n\n    return element;\n  }\n\n  /**\n   * @return {boolean} `true` when the queue is empty\n   */\n  isEmpty() {\n    return Boolean(this.queue.length === 0);\n  }\n\n  /**\n   * Check if the queue has a key in it\n   *\n   * @param {any} key   Key to lookup\n   * @return {boolean}\n   */\n  has(key) {\n    return this.keys.has(key);\n  }\n\n  /**\n   * Get the element in the queue with the specified key\n   *\n   * @param {any} key   Key to lookup\n   * @return {object}\n   */\n  get(key) {\n    return this.queue.find((element) => element.key === key);\n  }\n}\n","/**\n * Removes a key and all of its references from a map.\n * This function has no side-effects as it returns\n * a brand new map.\n *\n * @param {Map}     map - Map to remove the key from\n * @param {string}  key - Key to remove from the map\n * @return {Map}    New map without the passed key\n */\nexport function removeDeepFromMap(map, key) {\n  const newMap = new Map();\n\n  for (const [aKey, val] of map) {\n    if (aKey !== key && val instanceof Map) {\n      newMap.set(aKey, removeDeepFromMap(val, key));\n    } else if (aKey !== key) {\n      newMap.set(aKey, val);\n    }\n  }\n\n  return newMap;\n}\n","import { PriorityQueue } from \"./PriorityQueue\";\nimport { removeDeepFromMap } from \"./removeDeepFromMap\";\n\nclass Graph {\n  constructor(seed) {\n    this.graph = new Map();\n\n    if (seed) {\n      for (var a in seed) {\n        for (var b in seed[a]) {\n          this.connect(a, b, seed[a][b]);\n        }\n      }\n    }\n  }\n\n  /**\n   * Add a single connection to the graph.\n   *\n   * @param {any} nodeA - Name of start node\n   * @param {any} nodeB - Name of end node\n   * @param {number} cost - Weight value for connection\n   * @returns{this}\n   */\n  connect(nodeA, nodeB, cost) {\n    if (this.graph.has(nodeA) === false) {\n      let connections = new Map();\n\n      connections.set(nodeB, cost);\n\n      this.graph.set(nodeA, connections);\n    } else {\n      this.graph.get(nodeA).set(nodeB, cost);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes a node and all of its references from the graph\n   *\n   * @param {any} node - Node to remove from the graph\n   * @return {this}\n   * @example\n   *\n   * const route = new Graph({\n   *   A: { B: 1, C: 5 },\n   *   B: { A: 3 },\n   *   C: { B: 2, A: 2 },\n   * });\n   *\n   * route.removeNode('C');\n   * // The graph now is:\n   * // { A: { B: 1 }, B: { A: 3 } }\n   */\n  removeNode(key) {\n    this.graph = removeDeepFromMap(this.graph, key);\n\n    return this;\n  }\n\n  /**\n   * Compute the shortest path between the specified nodes\n   *\n   * @param {string}  start     - Starting node\n   * @param {string}  goal      - Node we want to reach\n   * @param {object}  [options] - Options\n   *\n   * @param {boolean} [options.trim]    - Exclude the origin and destination nodes from the result\n   * @param {boolean} [options.reverse] - Return the path in reversed order\n   * @param {boolean} [options.cost]    - Also return the cost of the path when set to true\n   *\n   * @return {array|object} Computed path between the nodes.\n   *\n   *  When `option.cost` is set to true, the returned value will be an object with shape:\n   *    - `path` *(Array)*: Computed path between the nodes\n   *    - `cost` *(Number)*: Cost of the path\n   *\n   * @example\n   *\n   * const route = new Graph()\n   *\n   * route.addNode('A', { B: 1 })\n   * route.addNode('B', { A: 1, C: 2, D: 4 })\n   * route.addNode('C', { B: 2, D: 1 })\n   * route.addNode('D', { C: 1, B: 4 })\n   *\n   * route.path('A', 'D') // => ['A', 'B', 'C', 'D']\n   *\n   * // trimmed\n   * route.path('A', 'D', { trim: true }) // => [B', 'C']\n   *\n   * // reversed\n   * route.path('A', 'D', { reverse: true }) // => ['D', 'C', 'B', 'A']\n   *\n   * // include the cost\n   * route.path('A', 'D', { cost: true })\n   * // => {\n   * //       path: [ 'A', 'B', 'C', 'D' ],\n   * //       cost: 4\n   * //    }\n   */\n  path(start, goal, options = {}) {\n    // Don't run when we don't have nodes set\n    if (!this.graph.size) {\n      if (options.cost) {\n        return { path: [], cost: 0 };\n      }\n\n      return [];\n    }\n\n    const explored = new Set();\n    const frontier = new PriorityQueue();\n    const previous = new Map();\n\n    let path = [];\n    let totalCost = 0;\n\n    let avoid = options.avoid ? new Set(options.avoid) : new Set();\n\n    if (avoid.has(start)) {\n      throw new Error(`Starting node (${start}) cannot be avoided`);\n    } else if (avoid.has(goal)) {\n      throw new Error(`Ending node (${goal}) cannot be avoided`);\n    }\n\n    // Add the starting point to the frontier, it will be the first node visited\n    frontier.set(start, 0);\n\n    // Run until we have visited every node in the frontier\n    while (!frontier.isEmpty()) {\n      // Get the node in the frontier with the lowest cost (`priority`)\n      const node = frontier.next();\n\n      // When the node with the lowest cost in the frontier in our goal node,\n      // we can compute the path and exit the loop\n      if (node.key === goal) {\n        // Set the total cost to the current value\n        totalCost = node.priority;\n\n        let nodeKey = node.key;\n        while (previous.has(nodeKey)) {\n          path.push(nodeKey);\n          nodeKey = previous.get(nodeKey);\n        }\n\n        break;\n      }\n\n      // Add the current node to the explored set\n      explored.add(node.key);\n\n      // Loop all the neighboring nodes\n      const neighbors = this.graph.get(node.key) || new Map();\n      neighbors.forEach((nCost, nNode) => {\n        // If we already explored the node, or the node is to be avoided, skip it\n        if (explored.has(nNode) || avoid.has(nNode)) return null;\n\n        // If the neighboring node is not yet in the frontier, we add it with\n        // the correct cost\n        if (!frontier.has(nNode)) {\n          previous.set(nNode, node.key);\n          return frontier.set(nNode, node.priority + nCost);\n        }\n\n        const frontierPriority = frontier.get(nNode).priority;\n        const nodeCost = node.priority + nCost;\n\n        // Otherwise we only update the cost of this node in the frontier when\n        // it's below what's currently set\n        if (nodeCost < frontierPriority) {\n          previous.set(nNode, node.key);\n          return frontier.set(nNode, nodeCost);\n        }\n\n        return null;\n      });\n    }\n\n    // Return null when no path can be found\n    if (!path.length) {\n      if (options.cost) {\n        return { path: [], cost: 0 };\n      }\n\n      return [];\n    }\n\n    // From now on, keep in mind that `path` is populated in reverse order,\n    // from destination to origin\n\n    // Remove the first value (the goal node) if we want a trimmed result\n    if (options.trim) {\n      path.shift();\n    } else {\n      // Add the origin waypoint at the end of the array\n      path = path.concat([start]);\n    }\n\n    // Reverse the path if we don't want it reversed, so the result will be\n    // from `start` to `goal`\n    if (!options.reverse) {\n      path = path.reverse();\n    }\n\n    // Return an object if we also want the cost\n    if (options.cost) {\n      return {\n        path,\n        cost: totalCost,\n      };\n    }\n\n    return path;\n  }\n\n  /**\n   * Find the closest node connecting to a given node\n   * @param {any} origin - Starting node\n   * @return {node}\n   */\n  closest(origin) {\n    if (this.graph.has(origin) === false) {\n      return null;\n    }\n\n    let cheapest = Infinity;\n    let closest = null;\n\n    this.graph.get(origin).forEach((cost, node) => {\n      if (cost < cheapest) {\n        closest = node;\n        cheapest = cost;\n      }\n    });\n\n    return closest;\n  }\n\n  /**\n   * Get a list of all nodes connected to a given node\n   *\n   * @param {any} origin - Starting node\n   * @return {Array[node]}\n   */\n  connections(origin) {\n    if (this.graph.has(origin)) {\n      return Array.from(this.graph.get(origin).keys());\n    }\n\n    return [];\n  }\n}\n\nexport default Graph;\n"],"names":["PriorityQueue","[object Object]","this","keys","Set","queue","sort","a","b","priority","key","value","Number","isNaN","TypeError","has","map","element","Object","assign","add","push","length","shift","delete","Boolean","find","removeDeepFromMap","newMap","Map","aKey","val","set","seed","graph","connect","nodeA","nodeB","cost","connections","get","start","goal","options","size","path","explored","frontier","previous","totalCost","avoid","Error","isEmpty","node","next","nodeKey","forEach","nCost","nNode","frontierPriority","nodeCost","trim","concat","reverse","origin","cheapest","Infinity","closest","Array","from"],"mappings":"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"}