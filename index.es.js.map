{"version":3,"file":"index.es.js","sources":["libs/PriorityQueue.js","libs/toDeepMap.js","libs/validateDeep.js","libs/Graph.js","libs/removeDeepFromMap.js"],"sourcesContent":["/**\n * This very basic implementation of a priority queue is used to select the\n * next node of the graph to walk to.\n *\n * The queue is always sorted to have the least expensive node on top.\n * Some helper methods are also implemented.\n *\n * You should **never** modify the queue directly, but only using the methods\n * provided by the class.\n */\nexport class PriorityQueue {\n  /**\n   * Creates a new empty priority queue\n   */\n  constructor() {\n    // The `keys` set is used to greatly improve the speed at which we can\n    // check the presence of a value in the queue\n    this.keys = new Set();\n    this.queue = [];\n  }\n\n  /**\n   * Sort the queue to have the least expensive node to visit on top\n   *\n   * @private\n   */\n  sort() {\n    this.queue.sort((a, b) => a.priority - b.priority);\n  }\n\n  /**\n   * Sets a priority for a key in the queue.\n   * Inserts it in the queue if it does not already exists.\n   *\n   * @param {any}     key       Key to update or insert\n   * @param {number}  value     Priority of the key\n   * @return {number} Size of the queue\n   */\n  set(key, value) {\n    const priority = Number(value);\n    if (isNaN(priority)) throw new TypeError('\"priority\" must be a number');\n\n    if (!this.keys.has(key)) {\n      // Insert a new entry if the key is not already in the queue\n      this.keys.add(key);\n      this.queue.push({ key, priority });\n    } else {\n      // Update the priority of an existing key\n      this.queue.map((element) => {\n        if (element.key === key) {\n          Object.assign(element, { priority });\n        }\n\n        return element;\n      });\n    }\n\n    this.sort();\n    return this.queue.length;\n  }\n\n  /**\n   * The next method is used to dequeue a key:\n   * It removes the first element from the queue and returns it\n   *\n   * @return {object} First priority queue entry\n   */\n  next() {\n    const element = this.queue.shift();\n\n    // Remove the key from the `_keys` set\n    this.keys.delete(element.key);\n\n    return element;\n  }\n\n  /**\n   * @return {boolean} `true` when the queue is empty\n   */\n  isEmpty() {\n    return Boolean(this.queue.length === 0);\n  }\n\n  /**\n   * Check if the queue has a key in it\n   *\n   * @param {any} key   Key to lookup\n   * @return {boolean}\n   */\n  has(key) {\n    return this.keys.has(key);\n  }\n\n  /**\n   * Get the element in the queue with the specified key\n   *\n   * @param {any} key   Key to lookup\n   * @return {object}\n   */\n  get(key) {\n    return this.queue.find((element) => element.key === key);\n  }\n}\n","/**\n * Validates a cost for a node\n *\n * @private\n * @param {number} val - Cost to validate\n * @return {bool}\n */\nfunction isValidNode(val) {\n  const cost = Number(val);\n\n  if (isNaN(cost) || cost <= 0) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Creates a deep `Map` from the passed object.\n *\n * @param  {Object} source - Object to populate the map with\n * @return {Map} New map with the passed object data\n */\nexport function toDeepMap(source) {\n  const map = new Map();\n  const keys = Object.keys(source);\n\n  keys.forEach((key) => {\n    const val = source[key];\n\n    if (val !== null && typeof val === \"object\" && !Array.isArray(val)) {\n      return map.set(key, toDeepMap(val));\n    }\n\n    if (!isValidNode(val)) {\n      throw new Error(`Invalid node: ${key}: ${val}`);\n    }\n\n    return map.set(key, Number(val));\n  });\n\n  return map;\n}\n","/**\n * Validate a map to ensure all it's values are either a number or a map\n *\n * @param {Map} map - Map to valiadte\n */\nexport function validateDeep(map) {\n  if (!(map instanceof Map)) {\n    throw new Error(`Invalid graph: Expected Map instead found ${typeof map}`);\n  }\n\n  map.forEach((value, key) => {\n    if (typeof value === \"object\" && value instanceof Map) {\n      validateDeep(value);\n      return;\n    }\n\n    if (typeof value !== \"number\" || value <= 0) {\n      throw new Error(\n        `Values must be numbers greater than 0. Found value ${value} at ${key}`\n      );\n    }\n  });\n}\n","import { PriorityQueue } from \"./PriorityQueue\";\nimport { removeDeepFromMap } from \"./removeDeepFromMap\";\nimport { toDeepMap } from \"./toDeepMap\";\nimport { validateDeep } from \"./validateDeep\";\n\nconst NO_ROUTE = { path: [], cost: 0 };\n\n/** Creates and manages a graph */\nclass Graph {\n  /**\n   * Creates a new Graph, optionally initializing it a nodes graph representation.\n   *\n   * A graph representation is an object that has as keys the name of the point and as values\n   * the points reacheable from that node, with the cost to get there:\n   *\n   *     {\n   *       node (Number|String): {\n   *         neighbor (Number|String): cost (Number),\n   *         ...,\n   *       },\n   *     }\n   *\n   * In alternative to an object, you can pass a `Map` of `Map`. This will\n   * allow you to specify numbers as keys.\n   *\n   * @param {Object|Map} [graph] - Initial graph definition\n   * @example\n   *\n   * const route = new Graph();\n   *\n   * // Pre-populated graph\n   * const route = new Graph({\n   *   A: { B: 1 },\n   *   B: { A: 1, C: 2, D: 4 },\n   * });\n   *\n   * // Passing a Map\n   * const g = new Map()\n   *\n   * const a = new Map()\n   * a.set('B', 1)\n   *\n   * const b = new Map()\n   * b.set('A', 1)\n   * b.set('C', 2)\n   * b.set('D', 4)\n   *\n   * g.set('A', a)\n   * g.set('B', b)\n   *\n   * const route = new Graph(g)\n   */\n  constructor(graph) {\n    if (graph instanceof Map) {\n      validateDeep(graph);\n      this.graph = graph;\n    } else if (graph) {\n      this.graph = toDeepMap(graph);\n    } else {\n      this.graph = new Map();\n    }\n  }\n\n  /**\n   * Adds a node to the graph\n   *\n   * @param {string} name - Name of the node\n   * @param {Object|Map} neighbors - Neighbouring nodes and cost to reach them\n   * @return {this}\n   * @example\n   *\n   * const route = new Graph();\n   *\n   * route.addNode('A', { B: 1 });\n   *\n   * // It's possible to chain the calls\n   * route\n   *   .addNode('B', { A: 1 })\n   *   .addNode('C', { A: 3 });\n   *\n   * // The neighbors can be expressed in a Map\n   * const d = new Map()\n   * d.set('A', 2)\n   * d.set('B', 8)\n   *\n   * route.addNode('D', d)\n   */\n  addNode(name, neighbors) {\n    let nodes;\n    if (neighbors instanceof Map) {\n      validateDeep(neighbors);\n      nodes = neighbors;\n    } else {\n      nodes = toDeepMap(neighbors);\n    }\n\n    this.graph.set(name, nodes);\n\n    return this;\n  }\n\n  /**\n   * Add a single connection to the graph.\n   *\n   * @param {string} nodeA - Name of start node\n   * @param {string} nodeB - Name of end node\n   * @param {number} weight - Weight value for connection\n   * @returns{this}\n   */\n  connect(nodeA, nodeB, weight) {\n    if (this.graph.has(nodeA) === false) {\n      let connections = new Map();\n\n      connections.set(nodeB, weight);\n\n      this.graph.set(nodeA, connections);\n    } else {\n      this.graph.get(nodeA).set(nodeB, weight);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes a node and all of its references from the graph\n   *\n   * @param {string|number} key - Key of the node to remove from the graph\n   * @return {this}\n   * @example\n   *\n   * const route = new Graph({\n   *   A: { B: 1, C: 5 },\n   *   B: { A: 3 },\n   *   C: { B: 2, A: 2 },\n   * });\n   *\n   * route.removeNode('C');\n   * // The graph now is:\n   * // { A: { B: 1 }, B: { A: 3 } }\n   */\n  removeNode(key) {\n    this.graph = removeDeepFromMap(this.graph, key);\n\n    return this;\n  }\n\n  /**\n   * Compute the shortest path between the specified nodes\n   *\n   * @param {string}  start     - Starting node\n   * @param {string}  goal      - Node we want to reach\n   * @param {object}  [options] - Options\n   *\n   * @param {boolean} [options.trim]    - Exclude the origin and destination nodes from the result\n   * @param {boolean} [options.reverse] - Return the path in reversed order\n   * @param {boolean} [options.cost]    - Also return the cost of the path when set to true\n   *\n   * @return {array|object} Computed path between the nodes.\n   *\n   *  When `option.cost` is set to true, the returned value will be an object with shape:\n   *    - `path` *(Array)*: Computed path between the nodes\n   *    - `cost` *(Number)*: Cost of the path\n   *\n   * @example\n   *\n   * const route = new Graph()\n   *\n   * route.addNode('A', { B: 1 })\n   * route.addNode('B', { A: 1, C: 2, D: 4 })\n   * route.addNode('C', { B: 2, D: 1 })\n   * route.addNode('D', { C: 1, B: 4 })\n   *\n   * route.path('A', 'D') // => ['A', 'B', 'C', 'D']\n   *\n   * // trimmed\n   * route.path('A', 'D', { trim: true }) // => [B', 'C']\n   *\n   * // reversed\n   * route.path('A', 'D', { reverse: true }) // => ['D', 'C', 'B', 'A']\n   *\n   * // include the cost\n   * route.path('A', 'D', { cost: true })\n   * // => {\n   * //       path: [ 'A', 'B', 'C', 'D' ],\n   * //       cost: 4\n   * //    }\n   */\n  path(start, goal, options = {}) {\n    // Don't run when we don't have nodes set\n    if (!this.graph.size) {\n      if (options.cost) {\n        return NO_ROUTE;\n      }\n\n      return [];\n    }\n\n    const explored = new Set();\n    const frontier = new PriorityQueue();\n    const previous = new Map();\n\n    let path = [];\n    let totalCost = 0;\n\n    let avoid = [];\n    if (options.avoid) {\n      avoid = [].concat(options.avoid);\n    }\n\n    if (avoid.includes(start)) {\n      throw new Error(`Starting node (${start}) cannot be avoided`);\n    } else if (avoid.includes(goal)) {\n      throw new Error(`Ending node (${goal}) cannot be avoided`);\n    }\n\n    // Add the starting point to the frontier, it will be the first node visited\n    frontier.set(start, 0);\n\n    // Run until we have visited every node in the frontier\n    while (!frontier.isEmpty()) {\n      // Get the node in the frontier with the lowest cost (`priority`)\n      const node = frontier.next();\n\n      // When the node with the lowest cost in the frontier in our goal node,\n      // we can compute the path and exit the loop\n      if (node.key === goal) {\n        // Set the total cost to the current value\n        totalCost = node.priority;\n\n        let nodeKey = node.key;\n        while (previous.has(nodeKey)) {\n          path.push(nodeKey);\n          nodeKey = previous.get(nodeKey);\n        }\n\n        break;\n      }\n\n      // Add the current node to the explored set\n      explored.add(node.key);\n\n      // Loop all the neighboring nodes\n      const neighbors = this.graph.get(node.key) || new Map();\n      neighbors.forEach((nCost, nNode) => {\n        // If we already explored the node, or the node is to be avoided, skip it\n        if (explored.has(nNode) || avoid.includes(nNode)) return null;\n\n        // If the neighboring node is not yet in the frontier, we add it with\n        // the correct cost\n        if (!frontier.has(nNode)) {\n          previous.set(nNode, node.key);\n          return frontier.set(nNode, node.priority + nCost);\n        }\n\n        const frontierPriority = frontier.get(nNode).priority;\n        const nodeCost = node.priority + nCost;\n\n        // Otherwise we only update the cost of this node in the frontier when\n        // it's below what's currently set\n        if (nodeCost < frontierPriority) {\n          previous.set(nNode, node.key);\n          return frontier.set(nNode, nodeCost);\n        }\n\n        return null;\n      });\n    }\n\n    // Return null when no path can be found\n    if (!path.length) {\n      if (options.cost) {\n        return NO_ROUTE\n      };\n\n      return NO_ROUTE.path;\n    }\n\n    // From now on, keep in mind that `path` is populated in reverse order,\n    // from destination to origin\n\n    // Remove the first value (the goal node) if we want a trimmed result\n    if (options.trim) {\n      path.shift();\n    } else {\n      // Add the origin waypoint at the end of the array\n      path = path.concat([start]);\n    }\n\n    // Reverse the path if we don't want it reversed, so the result will be\n    // from `start` to `goal`\n    if (!options.reverse) {\n      path = path.reverse();\n    }\n\n    // Return an object if we also want the cost\n    if (options.cost) {\n      return {\n        path,\n        cost: totalCost,\n      };\n    }\n\n    return path;\n  }\n}\n\nexport default Graph;\n","/**\n * Removes a key and all of its references from a map.\n * This function has no side-effects as it returns\n * a brand new map.\n *\n * @param {Map}     map - Map to remove the key from\n * @param {string}  key - Key to remove from the map\n * @return {Map}    New map without the passed key\n */\nexport function removeDeepFromMap(map, key) {\n  const newMap = new Map();\n\n  for (const [aKey, val] of map) {\n    if (aKey !== key && val instanceof Map) {\n      newMap.set(aKey, removeDeepFromMap(val, key));\n    } else if (aKey !== key) {\n      newMap.set(aKey, val);\n    }\n  }\n\n  return newMap;\n}\n"],"names":["PriorityQueue","[object Object]","this","keys","Set","queue","sort","a","b","priority","key","value","Number","isNaN","TypeError","has","map","element","Object","assign","add","push","length","shift","delete","Boolean","find","toDeepMap","source","Map","forEach","val","Array","isArray","set","cost","isValidNode","Error","validateDeep","NO_ROUTE","path","graph","name","neighbors","nodes","nodeA","nodeB","weight","connections","get","removeDeepFromMap","newMap","aKey","start","goal","options","size","explored","frontier","previous","totalCost","avoid","concat","includes","isEmpty","node","next","nodeKey","nCost","nNode","frontierPriority","nodeCost","trim","reverse"],"mappings":"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"}